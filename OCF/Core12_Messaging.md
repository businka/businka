[Copyright Open Connectivity Foundation, Inc. © 2016-2018. All rights Reserved](https://openconnectivity.org/)

# 12 Обмен сообщениями

## 12.1 Вступление

 В этом разделе указано сопоставление сообщений протокола для операций обмена сообщениями CRUDN (раздел 8) для каждого указанного протокола обмена сообщениями (например, CoAP.). Отображение дополнительных протоколов ожидается в более поздней версии этой спецификации. Вся информация о свойствах из модели ресурсов должна переноситься в пределах полезной нагрузки сообщения. Эта полезная нагрузка должна быть сгенерирована на уровне модели ресурсов и должна быть инкапсулирована на уровне подключения данных. Заголовок сообщения должен использоваться только для описания полезной нагрузки сообщения (например, глагола, типа mime-типа, информации полезной нагрузки сообщения), в дополнение к обязательным полям заголовка, определенным в спецификации протокола обмена сообщениями (например, CoAP).

Если заголовок сообщения не поддерживает это, эта информация также должна быть передана в полезной нагрузке сообщения. Информация о модели ресурса не должна включаться в структуру заголовка сообщения, если поле заголовка сообщения не является обязательным в спецификации протокола обмена сообщениями.

Когда ресурс задается с помощью спокойного языка описания, такого как RAML или Swagger2.0, тогда в описании используются определения синтаксиса HTTP (например, синтаксис HTTP для операций CRUDN, коды состояния и т.д.). Синтаксис HTTP будет сопоставлен с фактическим используемым протоколом веб-передачи (например, CoAP).

##  12.2   Mapping of CRUDN to CoAP

### 12.2.1 Overview

Устройство, реализующее CoAP, должно соответствовать IETF RFC 7252 для методов, указанных в разделе 12.2.3. Устройство, реализующее CoAP, должно соответствовать IETF RFC 7641 для реализации опции CoAP Observe. Поддержка передачи блока CoAP, когда полезная нагрузка больше MTU, определена в разделе 12.2.8.

### 12.2.2 URIs

OCF: URI сопоставляется с coap: URI, заменяя имя схемы «ocf» на «coap», если небезопасный или «coaps», если он защищен до отправки по сети запрашивающим. Аналогично на приемнике сторона, название схемы заменяется на «ocf».

Любая строка запроса, которая присутствует в URI, кодируется как один или несколько параметров URI-запроса, как определено в разделе 6.4 раздела IETF RFC 7252. 

### 12.2.3 CoAP method with request and response

#### 12.2.3.1 Overview

Каждый запрос имеет метод CoAP, который реализует запрос. Основные методы и их значения показаны в таблице 38, которая обеспечивает сопоставление методов GET / PUT / POST / DELETE для операций CREATE, RETRIEVE, UPDATE и DELETE. Связанный текст предоставляет общее поведение при использовании этих методов, однако интерфейсы ресурсов могут изменять эту обобщенную семантику. Коды HTTP в успокоительных описаниях будут переведены, как описано в IETF RFC 8075, раздел 7 «Сопоставление кода ответа».

 **Table 38. CoAP request and response** 

| Method for CRUDN     | **(mandatory) Request data**                                 | **(mandatory)   Response data**                              |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **GET for RETRIEVE** | - **Method code**: GET (0.01)   - **Request URI**: an existing URI for the   Resource to be retrieved | - **Response code** : success (2 .xx) or error (4.xx or 5.xx)   - **Payloa**d: Resource representation of the target Resource (when   successful) |
| **POST for CREATE**  | - **Method code**: POST (0.02)   - **Request URI**: существующий URI для Ресурса, ответственного за создание   - **Payload**: Resource presentation of the Re source to be created | - **Response code** : success (2 .xx) or error (4.xx or 5.xx)   - **Payload**: the URI of the newly created Resource(when successful). |
| **PUT for CREATE**   | - **Method code**: PUT (0.03)   - **Request URI**: a new URI for the Resource to be created.   - **Payload** : Resource presentation of the Resource to be created. | - **Response code** : success (2.xx) or error (4.xx or 5.xx) |
| **POST for UPDATE**  | - **Method code**: POST (0. 02)   - **Request URI**: существующий URI для ресурса, подлежащего обновлению.   - **Payload**: representation of the Re source to be updated. | - **Response Code**: success (2 . xx) or error (4.xx or 5  xx) |

####  12.2.3.2 CREATE with POST or PUT

##### 12.2.3.2.1 With POST

POST должен использоваться только в ситуациях, когда URI запроса действителен, то есть URI существующего Ресурса на Сервере, который обрабатывает запрос. Если такой ресурс отсутствует, Сервер должен ответить кодом ошибки 4.xx. Использование POST для CREATE должно использовать существующий URI запроса, который идентифицирует Ресурс на Сервере, ответственный за создание. URI созданного Ресурса определяется сервером и предоставляется Клиенту в ответе.

Клиент должен включать представление нового ресурса в полезной нагрузке запроса. Новое представление ресурса в полезной нагрузке должно иметь все необходимые свойства для создания действительного экземпляра ресурса, т. Е. Созданный ресурс должен иметь возможность правильно реагировать на действительный запрос с обязательным интерфейсом (например, «GET ? If = oic.if.baseline»).

После получения запроса POST Сервер должен либо

- создать новый ресурс с новым URI, ответить на новый URI для вновь созданного ресурса и код ответа на успех (2.xx); или же
- ответьте кодом ошибки (4.xx или 5.xx).

POST небезопасен и является поддерживаемым методом, когда идемпотентное поведение нельзя ожидать или гарантировать.

##### 12.2.3.2.2 With PUT

PUT должен использоваться для создания нового ресурса или полностью заменить полное представление существующего ресурса. Представление ресурсов в полезной нагрузке запроса PUT должно быть полным представлением. PUT для CREATE должен использовать новый URI запроса, определяющий новый ресурс, который будет создан.

Новое представление ресурса в полезной нагрузке должно иметь все необходимые свойства для создания действительного экземпляра ресурса, т. Е. Созданный Ресурс должен иметь возможность правильно реагировать на действительный запрос с обязательным интерфейсом (например, «GET with? If = oic.if.baseline «).

После получения запроса PUT сервер должен либо

- создать новый ресурс с URI запроса, предоставленным в запросе PUT, и отправить ответ с кодом ответа успеха (2.xx); или же
- ответьте кодом ошибки (4.xx или 5.xx).

PUT - небезопасный метод, но он является идемпотентным, поэтому, когда повторный запрос PUT повторяется, каждый раз каждый результат будет одинаковым.

#### 12.2.3.3 RETRIEVE with GET 

GET используется для операции RETRIEVE. Метод GET извлекает представление целевого ресурса, идентифицированного URI запроса.

Получив запрос GET, Сервер должен либо

- отправить ответ с представлением целевого ресурса с кодом ответа успеха (2.xx); или же

- отвечать кодом ошибки (4.xx или 5.xx) или игнорировать его (например, неприменимый многоадресный GET).


GET - безопасный метод и является идемпотентным.

#### 12.2.3.4 UPDATE with POST

POST должен использоваться только в ситуациях, когда URI запроса действителен, то есть URI существующего Ресурса на Сервере, который обрабатывает запрос. Если такой ресурс отсутствует, Сервер должен ответить кодом ошибки 4.xx. Клиент должен использовать POST для UPDATE значений свойства существующего ресурса (см. Разделы 3.1.32 и 8.4.2).

После получения запроса Сервер должен либо

- применить запрос к Ресурсу, идентифицированный URI запроса в соответствии с применяемым интерфейсом (т. Е. POST для несуществующих свойств игнорируется) и отправить ответ с кодом ответа успеха (2.xx); или

- ответьте кодом ошибки (4.xx или 5.xx). Обратите внимание, что если представление в полезной нагрузке несовместимо с целевым ресурсом для POST с использованием прикладного интерфейса (т. Е. Семантика «перезаписать» не может быть выполнена из-за свойства только для чтения в полезной нагрузке), тогда код ошибки 4.xx должен возвращаться.


POST небезопасен и является поддерживаемым методом, когда идемпотентное поведение невозможно ожидать или гарантировать.

#### 12.2.3.5 DELETE with DELETE 

DELETE используется для операции DELETE. Метод DELETE запрашивает удаление ресурса, идентифицированного с помощью URI запроса.

После получения запроса DELETE сервер должен либо

- удалить целевой ресурс и отправить ответ с кодом ответа успеха (2.xx); или же

- ответьте кодом ошибки (4.xx или 5.xx).


DELETE небезопасно, но idempotent (если URI не переработаны для новых экземпляров).

### 12.2.4 Content-Format negotiation

Рамочная программа OCF предусматривает поддержку CBOR, однако она позволяет вести переговоры с органом по полезной нагрузке, если поддерживается реализация более одного Content-Format (например, CBOR и JSON).

В этом случае параметр Accept, определенный в разделе 5.10.4 IETF RFC 7252, должен использоваться для указания того, какой Content-Format (например, JSON) запрашивается Клиентом.

Поддерживаемые форматы содержимого показаны в таблице 39.

| Media Type                 | ID    |
| -------------------------- | ----- |
| "application/cbor"         | 60    |
| “application/vnd.ocf+cbor” | 10000 |

Клиенты должны включать опцию Content-Format в каждое сообщение, которое содержит полезную нагрузку. Серверы должны включать опцию Content-Format для всех успешных (2.xx) ответов с телом полезной нагрузки. В соответствии с разделом 5.5.1 IETF RFC 7252 серверы должны включать опцию формата содержимого для всех ответов об ошибках (4.xx или 5.xx) с телом полезной нагрузки, если только они не включают диагностическую полезную нагрузку; Ответы об ошибках с диагностической полезной нагрузкой не включают параметр формата содержимого. Опция Content-Format должна использовать числовое значение столбца ID из таблицы 39. Вертикаль OCF может предписывать конкретную опцию Content-Format.

Клиенты также должны включать опцию «Принять» в каждое сообщение запроса. Опция Accept должна указывать требуемый Content-Format, как определено в Таблице 39 для ответных сообщений. Сервер должен вернуть требуемый контент-формат, если он доступен. Если требуемый Content-Format не может быть возвращен, то Сервер должен ответить соответствующим сообщением об ошибке.

### 12.2.5 Информация OCF-Content-Format-Version

Серверы и клиенты должны включать опцию OCF-Content-Format-Version в сообщениях запроса и ответа с полезной нагрузкой. Клиенты должны включать опцию OCF-Accept-Content-Format-Version в сообщениях запроса. Опция OCF-Content-Format-Version и опция OCF-Accept-Content-Format-Version указываются в качестве номеров опций в заголовке CoAP, как показано в таблице 40.

| CoAP Option Number | Name                              | Format | Length (bytes) |
| ------------------ | --------------------------------- | ------ | -------------- |
| 2049               | OCF-Accept-Content-Format-Version | unit   | 2              |
| 2053               | OCF-Content-Format-Version        | unit   | 2              |

Значением параметра OCF-Accept-Content-Format-Version и параметра OCF-Content-Format-Version является двухбайтовое целое число без знака, которое используется для определения основной, вспомогательной и вспомогательной версий. Основная и вспомогательная версии представлены 5 битами, а дополнительная версия представлена 6 битами, как показано в таблице 41.

| bits  |               |
| ----- | ------------- |
| 15-11 | Major version |
| 10-6  | Minor version |
| 5-0   | Sub version   |

Таблица 42 иллюстрирует несколько примеров:

| OCF version | Binary representation | Integer value |
| ----------- | --------------------- | ------------- |
| 1.0.0       | 0000 1000 0000 0000   | 2048          |
| 1.1.0       | 0000 1000 0100 0000   | 2112          |

Опция OCF-Accept-Content-Format-Version и опция OCF-Content-Format-Version для этой версии спецификации должны быть 1.0.0 (то есть 0b0000 1000 0000 0000).

### 12.2.6 Политика формата контента

Для обеспечения совместимости между устройствами, реализованными в различных версиях данной спецификации, Устройства должны следовать политике, как описано на Рисунке 28, Рисунке 29 и Рисунке 30.

![Figure 28 Content-Format Policy for OIC 1.1 Client and OIC 1.1 Server](figure\28.png)

Figure 28 Content-Format Policy for OIC 1.1 Client and OIC 1.1 Server

![Figure 29 Content-Format Policy for OCF 1.X Client with OIC 1.1 and OCF 1.X Server (Content-Format Mismatch)](figure\29.png)

Figure 29 Content-Format Policy for OCF 1.X Client with OIC 1.1 and OCF 1.X Servers (Content-Format Mismatch)

![Figure 30 Content-Format Policy for Future OCF Client with OCF 1.X Servers (Content-Format-Version Mismatch)](figure\30.png)

Figure 30 Content-Format Policy for Future OCF Client with OCF 1.X Servers (Content-Format-Version Mismatch)

Все устройства должны поддерживать текущие и все предыдущие параметры формата содержимого и версии OCF-Content-Format-Versions. Клиент должен отправлять сообщения запроса на обнаружение с текущими и всеми предыдущими версиями Content-Formats и OCF-Content-Format-Version, пока он не обнаружит все серверы в сети.

### 12.2.7 Коды ответов CRUDN to CoAP

Отображение кодов ответа операций CRUDN в коды ответов CoAP идентично кодам ответов, определенным в IETF RFC 7252.

### 12.2.8 Передача блоков CoAP

Базовые сообщения CoAP хорошо работают для небольших полезных нагрузок, типичных для легких IoT-устройств с ограниченными возможностями. Однако могут быть предусмотрены сценарии, в которых приложение должно передавать большие полезные нагрузки.
Блочная передача CoAP, как определено в IETF RFC 7959, должна использоваться всеми Серверами, которые генерируют полезную нагрузку контента, которая будет превышать размер дейтаграммы CoAP в результате обработки любой определенной операции CRUDN.
Аналогично, блочная передача CoAP, как определено в IETF RFC 7959, должна поддерживаться всеми Клиентами. Использование блочной передачи применяется как для приема полезных нагрузок, так и для передачи полезных нагрузок, которые будут превышать размер дейтаграммы CoAP.
Все блоки, которые отправляются с использованием этого механизма для одного экземпляра передачи, должны иметь одинаковую настройку надежности (т.е. все подтвержденные или все не подтвержденные).
Клиент может поддерживать как параметры block1 (как описательный), так и block2 (как управляющий), как описано в IETF RFC 7959. Сервер может поддерживать как опции block1 (как управляющий), так и block2 (как описательный), как описано в IETF RFC 7959.

## 12.3. Сопоставление сериализации CRUDN с CoAP по TCP

### 12.3.1 Обзор

В средах, где TCP уже доступен, CoAP может использовать его для обеспечения надежности. Также в некоторых средах UDP-трафик блокируется, поэтому развертывания могут использовать TCP. Например, рассмотрите облачное приложение, действующее как Клиент, и Сервер находится в доме пользователя. Сервер, который уже поддерживает CoAP в качестве протокола обмена сообщениями, может легко поддерживать сериализацию CoAP через TCP, а не использовать другой протокол обмена сообщениями. Устройство, реализующее сериализацию CoAP через TCP, должно соответствовать [IETF RFC 8323](https://tools.ietf.org/html/rfc8323).

### 12.3.2 URIs

Когда UDP заблокирован, клиенты зависят от предварительно настроенных деталей устройства, чтобы определить, поддерживает ли устройство CoAP сериализацию по TCP. Когда UDP не заблокирован, устройство, которое поддерживает сериализацию CoAP через TCP, должно заполнить параметр «eps» в ответе «/ oic / res», как определено в разделе 10.2, с помощью схемы (ов) URI, как определено в разделе 8.1 или 8.2 [IETF RFC 8323](https://tools.ietf.org/html/rfc8323). Для схемы URI «coaps + tcp», как определено в разделе 8.2 [IETF RFC 8323](https://tools.ietf.org/html/rfc8323), используется [IETF RFC 7301](https://tools.ietf.org/html/rfc7301). Кроме того, URI, используемые для сериализации CoAP через TCP, должны соответствовать разделу 12.2.2, заменяя имена схем именами схем, определенными в разделах 8.1 и 8.2 [IETF RFC 8323](https://tools.ietf.org/html/rfc8323) соответственно.

### 12.3.3 Метод CoAP с запросом и ответом

Методы CoAP, используемые для сериализации CoAP по TCP, должны соответствовать разделу 12.2.3.

### 12.3.4 Согласование форматов контента

Согласование формата содержимого, используемое для сериализации CoAP через TCP, должно соответствовать разделу 12.2.4.

### 12.3.5 Информация о формате OCF-Content-Format-Version

Информация о версии формата содержимого OCF, используемая для сериализации CoAP через TCP, должна соответствовать разделу 12.2.5.

### 12.3.6 Политика Content-Format

Политика форматирования содержимого, используемая для сериализации CoAP через TCP, должна соответствовать разделу 12.2.6.

### 12.3.7. Коды ответа CRUDN на CoAP

Коды ответа CRUDN на CoAP для сериализации CoAP по TCP должны соответствовать разделу 12.2.7.

### 12.3.8 Передача блока CoAP

Передача блока CoAP для сериализации CoAP через TCP должна соответствовать разделу 6 [IETF RFC 8323](https://tools.ietf.org/html/rfc8323).

### 12.3.9 Продолжайте жить (здоровье соединения)

Устройства, поддерживающие CoAP через TCP, должны использовать сообщения Ping и Pong, как описано в разделе 5.4 в [IETF RFC 8323](https://tools.ietf.org/html/rfc8323).

## 12.4 Кодировка полезной нагрузки в CBOR

Реализации OCF должны выполнять преобразование в CBOR из определенных JSON схем и JSON из CBOR в соответствии с разделом 4 IETF RFC 7049, если в этом разделе не указано иное.

Свойства, определенные как целое число JSON, должны быть закодированы в CBOR как целое число (основные типы CBOR 0 и 1). Свойства, определенные как число JSON, должны быть закодированы как целочисленные, с плавающей точкой с двойной или двойной точностью (основной тип CBOR 7, подтипы 26 и 27); выбор зависит от реализации. Не допускается использовать полуточность с плавающей запятой (CBOR major 7, sub-type 25). Целочисленные числа должны находиться в пределах отрезка [-2 ^ 53, 2 ^ 53]. Свойства, определенные как номер JSON, должны быть закодированы как целые числа, когда это возможно; если это невозможно. Свойства, определенные как номер JSON, должны использовать одну точность, если потеря точности не влияет на качество обслуживания, в противном случае свойство должно использовать двойную точность.

При получении полезной нагрузки CBOR реализация должна иметь возможность интерпретировать ЦЕЛИ ЦЕЛИ в любой позиции. Если свойство, определенное как целое число JSON, принимается закодированным, отличным от целого, реализация может отклонить эту кодировку, используя окончательный ответ, подходящий для основного транспорта (например, 4.00 для CoAP) и, таким образом, оптимизирует для целочисленного случая. Если свойство определено как номер JSON, реализация должна принимать целые числа с однократной и двойной точностью.