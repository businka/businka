Network Working Group                                    S. Blake-Wilson

Request for Comments: 4492                                       SafeNet

Category: Informational                                       N. Bolyard
                                                        Sun Microsystems
                                                                V. Gupta
                                                                Sun Labs
                                                                 C. Hawk
                                                               Corriente
                                                              B. Moeller
                                                         Ruhr-Uni Bochum
                                                                May 2006


Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)

Status of This Memo

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2006).

Abstract

   This document describes new key exchange algorithms based on Elliptic
   Curve Cryptography (ECC) for the Transport Layer Security (TLS)
   protocol.  In particular, it specifies the use of Elliptic Curve
   Diffie-Hellman (ECDH) key agreement in a TLS handshake and the use of
   Elliptic Curve Digital Signature Algorithm (ECDSA) as a new
   authentication mechanism.

# 1.  Introduction

   Elliptic Curve Cryptography (ECC) is emerging as an attractive
   public-key cryptosystem, in particular for mobile (i.e., wireless)
   environments.  Compared to currently prevalent cryptosystems such as
   RSA, ECC offers equivalent security with smaller key sizes.  This is
   illustrated in the following table, based on [18], which gives
   approximate comparable key sizes for symmetric- and asymmetric-key
   cryptosystems based on the best-known algorithms for attacking them.

                    Symmetric  |   ECC   |  DH/DSA/RSA
                   ------------+---------+-------------
                        80     |   163   |     1024
                       112     |   233   |     2048
                       128     |   283   |     3072
                       192     |   409   |     7680
                       256     |   571   |    15360

                  Table 1: Comparable Key Sizes (in bits)

   Smaller key sizes result in savings for power, memory, bandwidth, and
   computational cost that make ECC especially attractive for
   constrained environments.

   This document describes additions to TLS to support ECC, applicable
   both to TLS Version 1.0 [2] and to TLS Version 1.1 [3].  In
   particular, it defines

   o  the use of the Elliptic Curve Diffie-Hellman (ECDH) key agreement
      scheme with long-term or ephemeral keys to establish the TLS
      premaster secret, and

   o  the use of fixed-ECDH certificates and ECDSA for authentication of
      TLS peers.

   The remainder of this document is organized as follows.  Section 2
   provides an overview of ECC-based key exchange algorithms for TLS.
   Section 3 describes the use of ECC certificates for client
   authentication.  TLS extensions that allow a client to negotiate the
   use of specific curves and point formats are presented in Section 4.
   Section 5 specifies various data structures needed for an ECC-based
   handshake, their encoding in TLS messages, and the processing of
   those messages.  Section 6 defines new ECC-based cipher suites and
   identifies a small subset of these as recommended for all
   implementations of this specification.  Section 7 discusses security
   considerations.  Section 8 describes IANA considerations for the name
   spaces created by this document.  Section 9 gives acknowledgements.

   This is followed by the lists of normative and informative references
   cited in this document, the authors' contact information, and
   statements on intellectual property rights and copyrights.

   Implementation of this specification requires familiarity with TLS
   [2][3], TLS extensions [4], and ECC [5][6][7][11][17].

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [1].

# 2.  Key Exchange Algorithms

В этом документе представлены пять новых алгоритмов обмена ключами на 
основе ECC для TLS. Все они используют ECDH для вычисления главного секрета 
TLS, и они различаются только временем жизни ключей ECDH (долгосрочных или эфемерных) 
и механизмом (если есть), используемым для их аутентификации. Получение 
главного секрета TLS из главного секрета и последующее создание ключей массового 
шифрования / MAC и векторов инициализации не зависят от алгоритма обмена ключами 
и не зависят от введения ECC.

В таблице ниже приведены новые алгоритмы обмена ключами, которые имитируют 
DH_DSS, DHE_DSS, DH_RSA, DHE_RSA и DH_anon (см. [2] и [3]) соответственно.

          Key
          Exchange
          Algorithm           Description
          ---------           -----------

          ECDH_ECDSA          Fixed ECDH with ECDSA-signed certificates.

          ECDHE_ECDSA         Ephemeral ECDH with ECDSA signatures.

          ECDH_RSA            Fixed ECDH with RSA-signed certificates.

          ECDHE_RSA           Ephemeral ECDH with RSA signatures.

          ECDH_anon           Anonymous ECDH, no signatures.

                     Table 2: ECC Key Exchange Algorithms

   Механизмы обмена ключами ECDHE_ECDSA и ECDHE_RSA обеспечивают прямую 
   секретность. С помощью ECDHE_RSA сервер может повторно использовать свой 
   существующий сертификат RSA и легко соответствовать предпочтениям ограниченного 
   клиента по эллиптической кривой (см. Раздел 4). Однако вычислительные затраты, 
   которые несет сервер, выше для ECDHE_RSA, чем для традиционного обмена ключами 
   RSA, который не обеспечивает прямой секретности.

   Механизм ECDH_RSA требует, чтобы сервер получил сертификат ECC, но издатель 
   сертификата все еще может использовать существующий ключ RSA для подписи. Это 
   избавляет от необходимости обновлять ключи доверенных центров сертификации, 
   принимаемых клиентами TLS. Механизм ECDH_ECDSA требует ключей ECC для сервера, 
   а также для центра сертификации и лучше всего подходит для ограниченных устройств, 
   не способных поддерживать RSA.

   Алгоритм анонимного обмена ключами не обеспечивает аутентификацию сервера или клиента. 
   Как и другие обмены анонимными ключами TLS, он подвержен атакам типа «злоумышленник 
   в середине». Реализации этого алгоритма ДОЛЖНЫ обеспечивать аутентификацию другими 
   способами.

   Обратите внимание, что нет структурной разницы между ключами ECDH и ECDSA. Издатель 
   сертификата может использовать расширения X.509 v3 keyUsage и extendedKeyUsage, чтобы 
   ограничить использование открытого ключа ECC определенными вычислениями [15]. В этом 
   документе ключ ECC называется ECDH-совместимым, если его использование в ECDH разрешено. 
   Аналогично определяется возможность ECDSA.
   
              Client                                        Server
              ------                                        ------

              ClientHello          -------->
                                                       ServerHello
                                                      Certificate*
                                                ServerKeyExchange*
                                              CertificateRequest*+
                                   <--------       ServerHelloDone
              Certificate*+
              ClientKeyExchange
              CertificateVerify*+
              [ChangeCipherSpec]
              Finished             -------->
                                                [ChangeCipherSpec]
                                   <--------              Finished

              Application Data     <------->      Application Data


                * сообщение не отправляется при некоторых условиях
                * сообщение не отправляется, если не требуется аутентификация клиента

                 Figure 1: Message flow in a full TLS handshake


   На рисунке 1 показаны все сообщения, задействованные в протоколе установления 
   ключа TLS (также известном как полное рукопожатие). Добавление ECC имеет прямое 
   влияние только на ClientHello, ServerHello, сообщение сертификата сервера, 
   ServerKeyExchange, ClientKeyExchange, CertificateRequest, сообщение сертификата 
   клиента и CertificateVerify. Далее мы более подробно опишем каждый алгоритм обмена 
   ключами ECC с точки зрения содержания и обработки этих сообщений. Для простоты 
   изложения мы отложим обсуждение аутентификации клиента и связанных сообщений 
   (обозначенных знаком + на рисунке 1) до раздела 3, а дополнительных расширений, 
   специфичных для ECC (которые влияют на сообщения Hello), до раздела 4.

## 2.1.  ECDH_ECDSA

   В ECDH_ECDSA сертификат сервера ДОЛЖЕН содержать открытый ключ с поддержкой ECDH 
   и быть подписан с помощью ECDSA.

   Сообщение ServerKeyExchange НЕ ДОЛЖНО отправляться (сертификат сервера содержит всю 
   необходимую информацию о ключах, требуемую клиентом для получения главного секрета).

   Клиент генерирует пару ключей ECDH на той же кривой, что и долгосрочный открытый 
   ключ сервера, и отправляет свой открытый ключ в сообщении ClientKeyExchange (за 
   исключением случаев использования алгоритма аутентификации клиента ECDSA_fixed_ECDH 
   или RSA_fixed_ECDH, и в этом случае изменения из Раздела 3.2 или Раздела 3.3 подать 
   заявление).

   И клиент, и сервер выполняют операцию ECDH и используют полученный общий секрет в 
   качестве главного секрета. Все расчеты ECDH выполняются, как указано в разделе 5.10.

## 2.2.  ECDHE_ECDSA

   В ECDHE_ECDSA сертификат сервера ДОЛЖЕН содержать открытый ключ с поддержкой ECDSA 
   и быть подписан с помощью ECDSA.

   Сервер отправляет свой эфемерный открытый ключ ECDH и спецификацию соответствующей 
   кривой в сообщении ServerKeyExchange. Эти параметры ДОЛЖНЫ быть подписаны с помощью 
   ECDSA с использованием закрытого ключа, соответствующего открытому ключу в сертификате 
   сервера.

   Клиент генерирует пару ключей ECDH по той же кривой, что и эфемерный ключ ECDH сервера, 
   и отправляет свой открытый ключ в сообщении ClientKeyExchange.

   И клиент, и сервер выполняют операцию ECDH (раздел 5.10) и используют полученный общий 
   секрет в качестве основного секрета.

## 2.3.  ECDH_RSA

   Этот алгоритм обмена ключами аналогичен ECDH_ECDSA, за исключением того, что сертификат 
   сервера ДОЛЖЕН быть подписан с помощью RSA, а не ECDSA.

## 2.4.  ECDHE_RSA

   Этот алгоритм обмена ключами аналогичен ECDHE_ECDSA, за исключением того, что сертификат 
   сервера ДОЛЖЕН содержать открытый ключ RSA, авторизованный для подписи, и что подпись 
   в сообщении ServerKeyExchange должна быть вычислена с соответствующим закрытым ключом 
   RSA. Сертификат сервера ДОЛЖЕН быть подписан RSA.

## 2.5.  ECDH_anon

   В ECDH_anon сообщения Сертификат сервера, CertificateRequest, Сертификат клиента и 
   сообщения CertificateVerify НЕ ДОЛЖНЫ отправляться.
    
   Сервер ДОЛЖЕН отправить эфемерный открытый ключ ECDH и спецификацию соответствующей 
   кривой в сообщении ServerKeyExchange. Эти параметры НЕ ДОЛЖНЫ быть подписаны.
    
   Клиент генерирует пару ключей ECDH по той же кривой, что и эфемерный ключ ECDH 
   сервера, и отправляет свой открытый ключ в сообщении ClientKeyExchange.
    
   И клиент, и сервер выполняют операцию ECDH и используют полученный общий секрет 
   в качестве основного секрета. Все расчеты ECDH выполняются, как указано в 
   разделе 5.10.
    
   Обратите внимание, что хотя алгоритмы обмена ключами ECDH_ECDSA, ECDHE_ECDSA, 
   ECDH_RSA и ECDHE_RSA требуют, чтобы сертификат сервера был подписан определенной 
   схемой подписи, эта спецификация (после аналогичных случаев DH_DSS, DHE_DSS, 
   DH_RSA и DHE_RSA в [2] и [ 3]) не накладывает ограничений на схемы подписи, 
   используемые где-либо еще в цепочке сертификатов. (Часто такие ограничения будут 
   полезны, и ожидается, что они будут учтены в практике подписания сертификационных 
   органов. Однако такие ограничения в целом не требуются строго: даже если клиент 
   не в состоянии полностью подтвердить в данной цепочке клиент может иметь возможность 
   проверить сертификат сервера, полагаясь на доверенный центр сертификации, чей 
   сертификат появляется как один из промежуточных сертификатов в цепочке.)

# 3.  Client Authentication

   В этом документе определены три новых механизма аутентификации клиента, каждый из 
   которых назван в соответствии с типом задействованного сертификата клиента: 
   ECDSA_sign, ECDSA_fixed_ECDH и RSA_fixed_ECDH. Механизм ECDSA_sign можно использовать 
   с любыми неанонимными алгоритмами обмена ключами ECC, описанными в разделе 2, а 
   также с другими неанонимными (не-ECC) алгоритмами обмена ключами, определенными 
   в TLS [2] [3]. Механизмы ECDSA_fixed_ECDH и RSA_fixed_ECDH можно использовать 
   с ECDH_ECDSA и ECDH_RSA. Их использование с ECDHE_ECDSA и ECDHE_RSA запрещено, 
   поскольку использование долгосрочного клиентского ключа ECDH может поставить 
   под угрозу свойство прямой секретности этих алгоритмов.

   Сервер может запросить аутентификацию клиента на основе ECC, включив один или 
   несколько из этих типов сертификатов в свое сообщение CertificateRequest. 
   Сервер не должен включать какие-либо типы сертификатов, запрещенные для 
   согласованного алгоритма обмена ключами. Клиент должен проверить, обладает 
   ли он сертификатом, подходящим для любого из методов, предложенных сервером, и 
   готов ли он использовать его для аутентификации.

   Если эти условия не выполняются, клиент должен отправить сообщение сертификата 
   клиента, не содержащее сертификатов. В этом случае ClientKeyExchange следует 
   отправлять, как описано в разделе 2, а CertificateVerify отправлять не следует. 
   Если серверу требуется аутентификация клиента, он может ответить предупреждением 
   о фатальном сбое установления связи.

   Если у клиента есть соответствующий сертификат и он желает использовать его для 
   аутентификации, он должен отправить этот сертификат в сообщении сертификата клиента 
   (согласно разделу 5.6) и подтвердить владение закрытым ключом, соответствующим 
   сертифицированному ключу. Процесс определения соответствующего сертификата и 
   подтверждения владения различается для каждого механизма аутентификации и описан 
   ниже.

   ПРИМЕЧАНИЕ. Сервер может запрашивать (а клиент - отправлять) сертификат клиента 
   другого типа, чем сертификат сервера.

##3.1.  ECDSA_sign

   Чтобы использовать этот механизм аутентификации, клиент ДОЛЖЕН иметь сертификат, 
   содержащий открытый ключ с поддержкой ECDSA и подписанный с помощью ECDSA.

   Клиент доказывает, что владеет закрытым ключом, соответствующим сертифицированному 
   ключу, включив подпись в сообщение CertificateVerify, как описано в Разделе 5.8.

## 3.2.  ECDSA_fixed_ECDH

   Чтобы использовать этот механизм аутентификации, клиент ДОЛЖЕН иметь сертификат, 
   содержащий открытый ключ с поддержкой ECDH, и этот сертификат ДОЛЖЕН быть подписан 
   с помощью ECDSA. Кроме того, ключ ECDH клиента ДОЛЖЕН находиться на той же 
   эллиптической кривой, что и долгосрочный (сертифицированный) ключ ECDH сервера. 
   Это может ограничить использование этого механизма закрытыми средами. В ситуациях, 
   когда у клиента есть ключ ECC на другой кривой, он должен будет аутентифицироваться 
   с использованием либо ECDSA_sign, либо механизма без ECC (например, RSA). Использование 
   фиксированного ECDH как для серверов, так и для клиентов в вычислительном отношении 
   более эффективно, чем механизмы, обеспечивающие прямую секретность.

   При использовании этого механизма аутентификации клиент ДОЛЖЕН отправить пустой 
   ClientKeyExchange, как описано в разделе 5.7, и НЕ ДОЛЖЕН отправлять сообщение 
   CertificateVerify. ClientKeyExchange пуст, поскольку открытый ключ ECDH клиента, 
   необходимый серверу для вычисления секрета премастера, доступен внутри сертификата 
   клиента. Способность клиента получить тот же главный секретный ключ, что и сервер 
   (продемонстрированная успешным обменом сообщениями Finished), доказывает владение 
   закрытым ключом, соответствующим сертифицированному открытому ключу, и сообщение 
   CertificateVerify не требуется.
   
## 3.3.  RSA_fixed_ECDH

   Этот механизм аутентификации идентичен ECDSA_fixed_ECDH, за исключением того, что 
   сертификат клиента ДОЛЖЕН быть подписан с помощью RSA.

   Обратите внимание, что хотя механизмы аутентификации клиента ECDSA_sign, 
   ECDSA_fixed_ECDH и RSA_fixed_ECDH требуют, чтобы сертификат клиента был 
   подписан определенной схемой подписи, эта спецификация не налагает ограничений 
   на схемы подписи, используемые где-либо еще в цепочке сертификатов. (Часто 
   такие ограничения будут полезны, и ожидается, что это будет учтено в практике 
   подписания сертификационных органов. Однако такие ограничения в целом не 
   требуются строго: даже если сервер не может полностью проверить в данной 
   цепочке сервер может иметь возможность проверить сертификат клиента, 
   полагаясь на якорь доверия, который появляется как один из промежуточных 
   сертификатов в цепочке.)
   
# 4.  TLS Extensions for ECC

   В этой спецификации определены два новых расширения TLS: (i) расширение 
   поддерживаемых эллиптических кривых и (ii) расширение поддерживаемых 
   форматов точек. Это позволяет согласовывать использование определенных 
   кривых и форматов точек (например, сжатого и несжатого соответственно) 
   во время квитирования, начиная новый сеанс. Эти расширения особенно 
   актуальны для ограниченных клиентов, которые могут поддерживать только 
   ограниченное количество кривых или форматов точек. Они следуют общему 
   подходу, изложенному в [4]; Детали сообщения указаны в Разделе 5. 
   Клиент перечисляет поддерживаемые им кривые и форматы точек, которые он 
   может анализировать, путем включения соответствующих расширений в свое 
   сообщение ClientHello. Сервер аналогичным образом перечисляет форматы 
   точек, которые он может анализировать, включая расширение в свое 
   сообщение ServerHello.

   Клиент TLS, который предлагает наборы шифров ECC в своем сообщении ClientHello, 
   ДОЛЖЕН включать эти расширения. Серверы, реализующие наборы шифров ECC, 
   ДОЛЖНЫ поддерживать эти расширения, и когда клиент использует эти расширения, 
   серверы НЕ ДОЛЖНЫ согласовывать использование набора шифров ECC, если они не 
   могут завершить рукопожатие, соблюдая выбор кривых и методов сжатия, указанных 
   клиентом. Это исключает возможность того, что согласованное квитирование ECC 
   будет впоследствии прервано из-за неспособности клиента работать с ключом 
   EC сервера.

   Клиент НЕ ДОЛЖЕН включать эти расширения в сообщение ClientHello, если он не 
   предлагает какие-либо наборы шифров ECC. Клиент, предлагающий комплекты шифров 
   ECC, может не включать эти расширения. В этом случае сервер может выбрать любой 
   из эллиптических кривых или форматов точек, перечисленных в Разделе 5. В этом
   разделе также более подробно описывается структура и обработка этих расширений.

   В случае возобновления сеанса сервер просто игнорирует расширение поддерживаемых 
   эллиптических кривых и расширение поддерживаемых форматов точек, появляющиеся в 
   текущем сообщении ClientHello. Эти расширения играют роль только во время 
   рукопожатий при согласовании нового сеанса.
   
# 5.  Data Structures and Computations

   В этом разделе описываются структуры данных и вычисления, используемые
   ключевыми механизмами на основе ECC, указанными в разделах 2, 3 и 4. 
   Используемый здесь язык представления такой же, как и используемый в 
   TLS [2] [3]. Поскольку эта спецификация расширяет TLS, эти описания 
   следует объединить с описаниями в спецификации TLS и любыми другими, 
   расширяющими TLS. Это означает, что типы перечислений могут не 
   указывать все возможные значения, а структуры с несколькими форматами, 
   выбранными с помощью предложения select (), могут не указывать все в
   озможные случаи.

## 5.1.  Client Hello Extensions

В этом разделе указываются два расширения TLS, которые могут быть включены 
в сообщение ClientHello, как описано в [4], «Расширение поддерживаемых э
ллиптических кривых» и «Расширение поддерживаемых форматов точек».

Когда отправляются эти расширения:

Расширения ДОЛЖНЫ быть отправлены вместе с любым сообщением ClientHello, 
которое предлагает наборы шифров ECC.

Значение этих расширений:

Эти расширения позволяют клиенту перечислять поддерживаемые им эллиптические 
кривые и / или форматы точек, которые он может анализировать.

Структура этих расширений:

Общая структура расширений TLS описана в [4], и эта спецификация добавляет 
два новых типа в ExtensionType.
    
       enum { elliptic_curves(10), ec_point_formats(11) } ExtensionType;

   elliptic_curves (Supported Elliptic Curves Extension):   Указывает набор 
        эллиптических кривых, поддерживаемых клиентом. Для этого расширения 
        непрозрачное поле extension_data содержит EllipticCurveList. За 
        подробностями обратитесь к Разделу 5.1.1.

   ec_point_formats (Supported Point Formats Extension):  Указывает набор 
        форматов точек, которые может анализировать клиент. Для этого расширения 
        непрозрачное поле extension_data содержит ECPointFormatList. За 
        подробностями обратитесь к Разделу 5.1.2.

Действия отправителя:

   Клиент, предлагающий наборы шифров ECC в своем сообщении ClientHello, добавляет 
   эти расширения (вместе с любыми другими), перечисляя поддерживаемые им кривые 
   и форматы точек, которые он может анализировать. Клиентам СЛЕДУЕТ отправлять 
   как расширение поддерживаемых эллиптических кривых, так и расширение поддерживаемых
    форматов точек. Если расширение поддерживаемых форматов точек действительно 
    отправлено, оно ДОЛЖНО содержать значение 0 (без сжатия) в качестве одного из 
    элементов в списке форматов точек.

   Действия получателя:

   Сервер, который получает сообщение ClientHello, содержащее одно или оба этих 
   расширения, ДОЛЖЕН использовать перечисленные возможности клиента для выбора 
   подходящего набора шифров. Один из предлагаемых наборов шифров ECC должен 
   согласовываться только в том случае, если сервер может успешно завершить квитирование 
   при использовании кривых и форматов точек, поддерживаемых клиентом (см. Разделы 5.3 и 5.4).


   ПРИМЕЧАНИЕ. Сервер, участвующий в обмене ключами ECDHE-ECDSA, может использовать 
   разные кривые для (i) ключа ECDSA в своем сертификате и (ii) эфемерного ключа ECDH 
   в сообщении ServerKeyExchange. Сервер должен учитывать расширения в обоих случаях.

   Если сервер не понимает расширение поддерживаемых эллиптических кривых, не понимает 
   расширение поддерживаемых форматов точек или не может выполнить квитирование ECC, о
   граничивая себя перечисленными кривыми и форматами точек, он НЕ ДОЛЖЕН согласовывать 
   использование шифра ECC. люкс. В зависимости от того, какие другие наборы шифров 
   предлагаются клиентом и поддерживаются сервером, это может привести к фатальному 
   предупреждению о сбое рукопожатия из-за отсутствия общих наборов шифров.
   
### 5.1.1.  Supported Elliptic Curves Extension

        enum {
            sect163k1 (1), sect163r1 (2), sect163r2 (3),
            sect193r1 (4), sect193r2 (5), sect233k1 (6),
            sect233r1 (7), sect239k1 (8), sect283k1 (9),
            sect283r1 (10), sect409k1 (11), sect409r1 (12),
            sect571k1 (13), sect571r1 (14), secp160k1 (15),
            secp160r1 (16), secp160r2 (17), secp192k1 (18),
            secp192r1 (19), secp224k1 (20), secp224r1 (21),
            secp256k1 (22), secp256r1 (23), secp384r1 (24),
            secp521r1 (25),
            reserved (0xFE00..0xFEFF),
            arbitrary_explicit_prime_curves(0xFF01),
            arbitrary_explicit_char2_curves(0xFF02),
            (0xFFFF)
        } NamedCurve;

sect163k1 и т. д.: указывает на поддержку соответствующей именованной кривой 
или класса явно определенных кривых. Именованные кривые, определенные здесь, 
указаны в SEC 2 [13]. Обратите внимание, что многие из этих кривых также 
рекомендуются в ANSI X9.62 [7] и FIPS 186-2 [11]. Значения от 0xFE00 до 0xFEFF 
зарезервированы для частного использования. Значения 0xFF01 и 0xFF02 указывают
 на то, что клиент поддерживает произвольные простые кривые и кривые-2, 
 соответственно (параметры кривой должны быть явно закодированы в параметрах 
 ECParameters).

Пространство имен NamedCurve поддерживается IANA. См. Раздел 8 для получения 
информации о том, как добавляются новые присвоения значений.
    
        struct {
            NamedCurve elliptic_curve_list<1..2^16-1>
        } EllipticCurveList;


Элементы в elliptic_curve_list упорядочены в соответствии с предпочтениями 
клиента (сначала предпочтительный выбор).

Например, клиент, который поддерживает только secp192r1 (он же NIST P-192; 
значение 19 = 0x0013) и secp224r1 (он же NIST P-224; значение 21 = 0x0015) 
и предпочитает использовать secp192r1, будет включать расширение TLS, 
состоящее из следующих октеты. Обратите внимание, что первые два октета 
указывают тип расширения (поддерживаемое расширение эллиптических кривых):

        00 0A 00 06 00 04 00 13 00 15

Клиент, поддерживающий произвольные явные кривые характеристики 2 (значение 
0xFF02), должен включать расширение, состоящее из следующих октетов:

        00 0A 00 04 00 02 FF 02

### 5.1.2.  Supported Point Formats Extension

        enum { uncompressed (0), ansiX962_compressed_prime (1),
               ansiX962_compressed_char2 (2), reserved (248..255)
        } ECPointFormat;

        struct {
            ECPointFormat ec_point_format_list<1..2^8-1>
        } ECPointFormatList;

В приведенное выше определение ECPointFormat включены три формата точек. 
Несжатый точечный формат является форматом по умолчанию, поскольку 
реализации этого документа ДОЛЖНЫ поддерживать его для всех поддерживаемых
кривых. Сжатые форматы точек уменьшают пропускную способность, включая 
только координату x и один бит координаты y точки. Реализации этого 
документа МОГУТ поддерживать форматы ansiX962_compressed_prime и 
ansiX962_compressed_char2, где первый применяется только к простым 
кривым, а второй - только к кривым характеристики 2. (Эти форматы 
указаны в [7].) Значения с 248 по 255 зарезервированы для частного 
использования.

Пространство имен ECPointFormat поддерживается IANA. См. Раздел 8 
для получения информации о том, как добавляются новые присвоения 
значений.

Элементы в ec_point_format_list упорядочены в соответствии с 
предпочтениями клиента (сначала предпочтительный выбор).

Клиент, который может анализировать только несжатый формат точки 
(значение 0), включает расширение, состоящее из следующих октетов; 
обратите внимание, что первые два октета указывают тип расширения 
(расширение поддерживаемых форматов точек):
   
        00 0B 00 02 01 00

Клиент, который в случае простых полей предпочитает сжатый формат 
(ansiX962_compressed_prime, значение 1) несжатому формату (значение 0), 
но в случае полей характеристики-2 предпочитает несжатый формат 
(значение 0) сжатому формату ( ansiX962_compressed_char2, значение 2), 
может указывать на эти предпочтения, включая расширение, состоящее из 
следующих октетов:

        00 0B 00 04 03 01 00 02

## 5.2.  Server Hello Extension

В этом разделе указывается расширение TLS, которое может быть включено в 
сообщение ServerHello, как описано в [4], Расширение поддерживаемых 
форматов точек.

Когда отправляется это расширение:

   Расширение поддерживаемых форматов точек включается в сообщение 
ServerHello в ответ на сообщение ClientHello, содержащее расширение 
поддерживаемых форматов точек, при согласовании набора шифров ECC.

   Значение этого расширения:

Это расширение позволяет серверу перечислять форматы точек, которые 
он может анализировать (для кривой, которая появится в его сообщении 
ServerKeyExchange при использовании алгоритма обмена ключами ECDHE_ECDSA, 
ECDHE_RSA или ECDH_anon, или для кривой, которая используется в открытом 
ключе сервера, который появится в его сообщении сертификата при 
использовании алгоритма обмена ключами ECDH_ECDSA или ECDH_RSA).

Структура этого расширения:

Расширение поддерживаемых форматов точек на сервере имеет ту же структуру, 
что и клиентское расширение поддерживаемых форматов точек (см. Раздел 5.1.2). 
Пункты в elliptic_curve_list здесь упорядочены в соответствии с предпочтениями 
сервера (сначала предпочтительный выбор). Обратите внимание, что сервер 
может включать элементы, которые не были найдены в списке клиента (например, 
сервер может предпочесть получать точки в сжатом формате, даже если клиент 
не может проанализировать этот формат: тот же клиент, тем не менее, может 
быть способен выводить точки в сжатом формате ).

Действия отправителя:

Сервер, который выбирает набор шифров ECC в ответ на сообщение ClientHello, 
включая расширение поддерживаемых форматов точек, добавляет это расширение 
(вместе с другими) к своему сообщению ServerHello, перечисляя форматы точек, 
которые он может анализировать. Расширение поддерживаемых форматов точек
при использовании ДОЛЖНО содержать значение 0 (без сжатия) в качестве 
одного из элементов в списке форматов точек.

Действия получателя:

Клиент, который получает сообщение ServerHello, содержащее расширение 
поддерживаемых форматов точек, ДОЛЖЕН учитывать выбор сервером форматов
точек во время квитирования (см. Разделы 5.6 и 5.7). Если расширение 
поддерживаемых форматов точек не получено с ServerHello, это эквивалентно 
расширению, допускающему только несжатый формат точки.
   
## 5.3.  Server Certificate

Когда это сообщение отправлено:

Это сообщение отправляется во всех неанонимных алгоритмах обмена ключами на основе ECC.

Значение этого сообщения:

Это сообщение используется для аутентичной передачи статического открытого ключа 
сервера клиенту. В следующей таблице показан тип сертификата сервера, подходящий 
для каждого алгоритма обмена ключами. Открытые ключи ECC ДОЛЖНЫ быть закодированы 
в сертификатах, как описано в разделе 5.9.

ПРИМЕЧАНИЕ. Сообщение сертификата сервера может содержать цепочку сертификатов. 
Ограничения, указанные в таблице 3, применяются только к сертификату сервера 
(первому в цепочке).
    
          Key Exchange Algorithm  Server Certificate Type
          ----------------------  -----------------------

          ECDH_ECDSA              Certificate MUST contain an
                                  ECDH-capable public key.  It
                                  MUST be signed with ECDSA.

          ECDHE_ECDSA             Certificate MUST contain an
                                  ECDSA-capable public key.  It
                                  MUST be signed with ECDSA.

          ECDH_RSA                Certificate MUST contain an
                                  ECDH-capable public key.  It
                                  MUST be signed with RSA.

          ECDHE_RSA               Certificate MUST contain an
                                  RSA public key authorized for
                                  use in digital signatures.  It
                                  MUST be signed with RSA.

                    Table 3: Server Certificate Types

Структура сообщения:

   Идентичен формату сертификата TLS.

   Действия отправителя:

   Сервер создает соответствующую цепочку сертификатов и передает ее клиенту в сообщении сертификата. Если клиент использовал расширение Supported Elliptic Curves Extension, открытый ключ в сертификате сервера ДОЛЖЕН соответствовать выбору клиента эллиптических кривых; в частности, открытый ключ ДОЛЖЕН использовать именованную кривую (а не ту же кривую, что и явная кривая), если клиент не указал поддержку явных кривых соответствующего типа. Если клиент использовал расширение поддерживаемых форматов точек, как точка открытого ключа сервера, так и (в случае явной кривой) базовая точка кривой ДОЛЖНЫ учитывать выбор клиентских форматов точек. (Сервер, который не может удовлетворить эти требования, НЕ ДОЛЖЕН выбирать набор шифров ECC в своем сообщении ServerHello.)

   Действия получателя:

   Клиент проверяет цепочку сертификатов, извлекает открытый ключ сервера и проверяет, подходит ли тип ключа согласованному алгоритму обмена ключами. (Возможная причина фатального отказа рукопожатия заключается в том, что возможности клиента по работе с эллиптическими кривыми и форматами точек превышены; см. Раздел 5.1.)
   
## 5.4.  Server Key Exchange

Когда это сообщение отправлено:

Это сообщение отправляется при использовании алгоритмов обмена ключами ECDHE_ECDSA, 
ECDHE_RSA и ECDH_anon.

Значение этого сообщения:

Это сообщение используется для передачи клиенту эфемерного открытого ключа ECDH 
сервера (и соответствующих параметров области эллиптической кривой).

Структура сообщения:
    
        enum { explicit_prime (1), explicit_char2 (2),
               named_curve (3), reserved(248..255) } ECCurveType;

   explicit_prime:   Указывает, что параметры области эллиптической кривой передаются 
         подробно, а лежащее в основе конечное поле является простым полем.

   explicit_char2:   Указывает, что параметры области эллиптической кривой переданы 
        подробно, а лежащее в основе конечное поле является полем характеристики 2.

   named_curve:   Указывает, что используется именованная кривая. Эту опцию СЛЕДУЕТ 
        использовать, когда это применимо.

Значения с 248 по 255 зарезервированы для частного использования.

Пространство имен ECCurveType поддерживается IANA. См. Раздел 8 для получения 
информации о том, как добавляются новые присвоения значений.

        struct {
            opaque a <1..2^8-1>;
            opaque b <1..2^8-1>;
        } ECCurve;


   a, b:   Эти параметры определяют коэффициенты эллиптической кривой. Каждое 
        значение содержит представление байтовой строки элемента поля после процедуры 
        преобразования, описанной в разделе 4.3.3 стандарта ANSI X9.62 [7].

        struct {
            opaque point <1..2^8-1>;
        } ECPoint;

   point:   Это представление точки эллиптической кривой в виде строки байтов 
        в соответствии с процедурой преобразования, описанной в разделе 4.3.6 
        стандарта ANSI X9.62 [7]. Эта байтовая строка может представлять точку 
        эллиптической кривой в несжатом или сжатом формате; он ДОЛЖЕН соответствовать 
        тому, что клиент запросил через расширение поддерживаемых форматов точек, 
        если это расширение использовалось.

        enum { ec_basis_trinomial, ec_basis_pentanomial } ECBasisType;

   ec_basis_trinomial:   Обозначает представление поля характеристики 2 с использованием трехчленного базиса.

   ec_basis_pentanomial:   Обозначает представление поля характеристики 2 с использованием пентаномиального базиса.

        struct {
            ECCurveType    curve_type;
            select (curve_type) {
                case explicit_prime:
                    opaque      prime_p <1..2^8-1>;
                    ECCurve     curve;
                    ECPoint     base;
                    opaque      order <1..2^8-1>;
                    opaque      cofactor <1..2^8-1>;
                case explicit_char2:
                    uint16      m;
                    ECBasisType basis;
                    select (basis) {
                        case ec_trinomial:
                            opaque  k <1..2^8-1>;
                        case ec_pentanomial:
                            opaque  k1 <1..2^8-1>;
                            opaque  k2 <1..2^8-1>;
                            opaque  k3 <1..2^8-1>;
                    };
                    ECCurve     curve;
                    ECPoint     base;
                    opaque      order <1..2^8-1>;
                    opaque      cofactor <1..2^8-1>;

                case named_curve:
                    NamedCurve namedcurve;
            };
        } ECParameters;

   curve_type:   This identifies the type of the elliptic curve domain      parameters.

   prime_p:   This is the odd prime defining the field Fp.

   curve:   Specifies the coefficients a and b of the elliptic curve E.

   base:   Specifies the base point G on the elliptic curve.

   order:   Specifies the order n of the base point.

   cofactor:   Specifies the cofactor h = #E(Fq)/n, where #E(Fq)      represents the number of points on the elliptic curve E defined      over the field Fq (either Fp or F2^m).

   m:   This is the degree of the characteristic-2 field F2^m.

   k:   The exponent k for the trinomial basis representation x^m + x^k
      +1.

   k1, k2, k3:   The exponents for the pentanomial representation x^m +
      x^k3 + x^k2 + x^k1 + 1 (such that k3 > k2 > k1).

   namedcurve:   Задает рекомендуемый набор параметров области эллиптической 
        кривой. Допускаются все значения NamedCurve, относящиеся к определенной 
        кривой. Значения NamedCurve, указывающие на поддержку класса явно определенных 
        кривых, здесь не разрешены (они допустимы только в расширении ClientHello); 
        это применимо к arbitrary_explicit_prime_curves (0xFF01) и 
        arbitrary_explicit_char2_curves (0xFF02).


        struct {
            ECParameters    curve_params;
            ECPoint         public;
        } ServerECDHParams;

   curve_params:   Задает параметры домена эллиптической кривой, связанные с открытым ключом ECDH.

   public:   Эфемерный открытый ключ ECDH.

   Сообщение ServerKeyExchange расширяется следующим образом.

        enum { ec_diffie_hellman } KeyExchangeAlgorithm;

   ec_diffie_hellman:   Указывает, что сообщение ServerKeyExchange содержит открытый ключ ECDH.

        select (KeyExchangeAlgorithm) {
            case ec_diffie_hellman:
                ServerECDHParams    params;
                Signature           signed_params;
        } ServerKeyExchange;

   params:   Задает открытый ключ ECDH и связанные с ним параметры домена.

   signed_params:   Хэш параметров с подписью, соответствующей примененному хешу. Для подписи 
        используется закрытый ключ, соответствующий сертифицированному открытому ключу в 
        сообщении сертификата сервера.

          enum { ecdsa } SignatureAlgorithm;

          select (SignatureAlgorithm) {
              case ecdsa:
                  digitally-signed struct {
                      opaque sha_hash[sha_size];
                  };
          } Signature;


        ServerKeyExchange.signed_params.sha_hash
            SHA(ClientHello.random + ServerHello.random +
                                              ServerKeyExchange.params);

   ПРИМЕЧАНИЕ. SignatureAlgorithm - это «rsa» для алгоритма обмена ключами 
   ECDHE_RSA и «анонимный» для ECDH_anon. Эти случаи определены в TLS [2] [3]. 
   SignatureAlgorithm - это "ecdsa" для ECDHE_ECDSA. Подписи ECDSA 
   генерируются и проверяются, как описано в Разделе 5.10, и SHA в приведенном 
   выше шаблоне для sha_hash соответственно может обозначать алгоритм хеширования, 
   отличный от SHA-1. Согласно ANSI X9.62 подпись ECDSA состоит из пары целых 
   чисел r и s. Элемент с цифровой подписью кодируется как непрозрачный вектор 
   <0..2 ^ 16-1>, содержимое которого является кодировкой DER [9], 
   соответствующей следующей нотации ASN.1 [8].

           Ecdsa-Sig-Value ::= SEQUENCE {
               r       INTEGER,
               s       INTEGER
           }

Действия отправителя:

Сервер выбирает параметры области эллиптической кривой и эфемерный открытый 
ключ ECDH, соответствующий этим параметрам, в соответствии со схемой 
ECKAS-DH1 из IEEE 1363 [6]. Он передает эту информацию клиенту в сообщении 
ServerKeyExchange, используя формат, определенный выше.

Действия получателя:

Клиент проверяет подпись (при ее наличии) и извлекает параметры домена 
эллиптической кривой сервера и эфемерный открытый ключ ECDH из сообщения 
ServerKeyExchange. (Возможная причина фатального отказа рукопожатия 
заключается в том, что возможности клиента по обработке эллиптических 
кривых и форматов точек превышены; см. Раздел 5.1.)

## 5.5.  Certificate Request

   When this message is sent:

   This message is sent when requesting client authentication.

   Meaning of this message:

   The server uses this message to suggest acceptable client
   authentication methods.

   Structure of this message:

   The TLS CertificateRequest message is extended as follows.

        enum {
            ecdsa_sign(64), rsa_fixed_ecdh(65),
            ecdsa_fixed_ecdh(66), (255)
        } ClientCertificateType;

   ecdsa_sign, etc.  Indicates that the server would like to use the
      corresponding client authentication method specified in Section 3.



   Actions of the sender:

   The server decides which client authentication methods it would like
   to use, and conveys this information to the client using the format
   defined above.

   Actions of the receiver:

   The client determines whether it has a suitable certificate for use
   with any of the requested methods and whether to proceed with client
   authentication.

## 5.6.  Client Certificate

   When this message is sent:

   This message is sent in response to a CertificateRequest when a
   client has a suitable certificate and has decided to proceed with
   client authentication.  (Note that if the server has used a Supported
   Point Formats Extension, a certificate can only be considered
   suitable for use with the ECDSA_sign, RSA_fixed_ECDH, and
   ECDSA_fixed_ECDH authentication methods if the public key point
   specified in it respects the server's choice of point formats.  If no
   Supported Point Formats Extension has been used, a certificate can
   only be considered suitable for use with these authentication methods
   if the point is represented in uncompressed point format.)

   Meaning of this message:

   This message is used to authentically convey the client's static
   public key to the server.  The following table summarizes what client
   certificate types are appropriate for the ECC-based client
   authentication mechanisms described in Section 3.  ECC public keys
   must be encoded in certificates as described in Section 5.9.

   NOTE: The client's Certificate message is capable of carrying a chain
   of certificates.  The restrictions mentioned in Table 4 apply only to
   the client's certificate (first in the chain).


          Client
          Authentication Method   Client Certificate Type
          ---------------------   -----------------------

          ECDSA_sign              Certificate MUST contain an
                                  ECDSA-capable public key and
                                  be signed with ECDSA.

          ECDSA_fixed_ECDH        Certificate MUST contain an
                                  ECDH-capable public key on the
                                  same elliptic curve as the server's
                                  long-term ECDH key.  This certificate
                                  MUST be signed with ECDSA.

          RSA_fixed_ECDH          Certificate MUST contain an
                                  ECDH-capable public key on the
                                  same elliptic curve as the server's
                                  long-term ECDH key.  This certificate
                                  MUST be signed with RSA.

                     Table 4: Client Certificate Types

   Structure of this message:

   Identical to the TLS client Certificate format.

   Actions of the sender:

   The client constructs an appropriate certificate chain, and conveys
   it to the server in the Certificate message.

   Actions of the receiver:

   The TLS server validates the certificate chain, extracts the client's
   public key, and checks that the key type is appropriate for the
   client authentication method.

## 5.7.  Client Key Exchange

Когда это сообщение отправлено:

   Это сообщение отправляется во всех алгоритмах обмена ключами. Если используется 
   аутентификация клиента с помощью ECDSA_fixed_ECDH или RSA_fixed_ECDH, это сообщение 
   будет пустым. В противном случае он содержит эфемерный открытый ключ ECDH клиента.

   Значение сообщения:

   Это сообщение используется для передачи эфемерных данных, относящихся к обмену ключами, 
   принадлежащего клиенту (например, его эфемерного открытого ключа ECDH).

   Структура сообщения:

   Сообщение TLS ClientKeyExchange расширяется следующим образом.
  
        enum { implicit, explicit } PublicValueEncoding;

   implicit, explicit:   для комплектов шифров ECC это указывает, находится ли открытый 
        ключ ECDH клиента в сертификате клиента («неявный» / "implicit"") или 
        предоставляется в виде эфемерного открытого ключа ECDH в сообщении ClientKeyExchange
        ("явный" / "explicit"). (Это «явно» в наборах шифров ECC, за исключением случаев,
        когда клиент использует механизм аутентификации клиента ECDSA_fixed_ECDH или 
        RSA_fixed_ECDH.)

        struct {
            select (PublicValueEncoding) {
                case implicit: struct { };
                case explicit: ECPoint ecdh_Yc;
            } ecdh_public;
        } ClientECDiffieHellmanPublic;

   ecdh_Yc:   Содержит эфемерный открытый ключ ECDH клиента в виде байтовой строки ECPoint.point, 
   которая может представлять точку эллиптической кривой в несжатом или сжатом формате. Здесь 
   формат ДОЛЖЕН соответствовать тому, что сервер запросил через расширение поддерживаемых 
   форматов точек, если это расширение использовалось, и ДОЛЖЕН быть несжатым, если это 
   расширение не использовалось.

        struct {
            select (KeyExchangeAlgorithm) {
                case ec_diffie_hellman: ClientECDiffieHellmanPublic;
            } exchange_keys;
        } ClientKeyExchange;

Действия отправителя:

   Клиент выбирает эфемерный открытый ключ ECDH, соответствующий параметрам, которые он 
   получил от сервера в соответствии со схемой ECKAS-DH1 из IEEE 1363 [6]. Он передает 
   эту информацию клиенту в сообщении ClientKeyExchange, используя формат, определенный выше.

   Действия получателя:

   Сервер извлекает эфемерный открытый ключ ECDH клиента из сообщения ClientKeyExchange и 
   проверяет, находится ли он на той же эллиптической кривой, что и ключ ECDH сервера.
   
## 5.8.  Certificate Verify

   When this message is sent:

   This message is sent when the client sends a client certificate
   containing a public key usable for digital signatures, e.g., when the
   client is authenticated using the ECDSA_sign mechanism.

   Meaning of the message:

   This message contains a signature that proves possession of the
   private key corresponding to the public key in the client's
   Certificate message.

   Structure of this message:

   The TLS CertificateVerify message and the underlying Signature type
   are defined in [2] and [3], and the latter is extended here in
   Section 5.4.  For the ecdsa case, the signature field in the
   CertificateVerify message contains an ECDSA signature computed over
   handshake messages exchanged so far, exactly similar to
   CertificateVerify with other signing algorithms in [2] and [3]:

        CertificateVerify.signature.sha_hash
            SHA(handshake_messages);

   ECDSA signatures are computed as described in Section 5.10, and SHA
   in the above template for sha_hash accordingly may denote a hash
   algorithm other than SHA-1.  As per ANSI X9.62, an ECDSA signature
   consists of a pair of integers, r and s.  The digitally-signed
   element is encoded as an opaque vector <0..2^16-1>, the contents of
   which are the DER encoding [9] corresponding to the following ASN.1
   notation [8].

        Ecdsa-Sig-Value ::= SEQUENCE {
            r       INTEGER,
            s       INTEGER
        }

   Actions of the sender:

   The client computes its signature over all handshake messages sent or
   received starting at client hello and up to but not including this
   message.  It uses the private key corresponding to its certified
   public key to compute the signature, which is conveyed in the format
   defined above.

   Actions of the receiver:

   The server extracts the client's signature from the CertificateVerify
   message, and verifies the signature using the public key it received
   in the client's Certificate message.

## 5.9.  Elliptic Curve Certificates

   Сертификаты X.509, содержащие открытые ключи ECC или подписанные с 
   использованием ECDSA, ДОЛЖНЫ соответствовать [14] или другому RFC, 
   который заменяет или расширяет его. Клиентам СЛЕДУЕТ использовать 
   параметры области эллиптической кривой, рекомендованные в ANSI X9.62 [7], 
   FIPS 186-2 [11] и SEC 2 [13].

## 5.10.  ECDH, ECDSA, and RSA Computations

   Все вычисления ECDH (включая генерацию параметров и ключей, а также вычисление 
   общего секрета) выполняются в соответствии с [6] с использованием схемы ECKAS-DH1
   с картой идентичности в качестве функции деривации ключей (KDF), так что главный 
   секрет - это x -координата точки эллиптической кривой общего секрета ECDH, 
   представленной в виде строки октетов. Обратите внимание, что эта строка октетов 
   (Z в терминологии IEEE 1363), выводимая FE2OSP, примитивом преобразования 
   элемента поля в строку октета, имеет постоянную длину для любого заданного поля; 
   начальные нули, обнаруженные в этой строке октетов, НЕ ДОЛЖНЫ быть обрезаны.

   (Обратите внимание, что такое использование идентификатора KDF является техническим. 
   Полная картина заключается в том, что ECDH используется с нетривиальным KDF, 
   потому что TLS напрямую не использует главный секрет для чего-либо, кроме вычисления 
   главного секрета. Начиная с TLS 1.0 [2] и 1.1 [3], это означает, что PRF TLS на 
   основе MD5 и SHA-1 служит в качестве KDF; вполне возможно, что будущие версии TLS 
   или новые расширения TLS, представленные в будущем, могут изменить это вычисление.)

   Все вычисления ECDSA ДОЛЖНЫ выполняться в соответствии с ANSI X9.62 [7] или его 
   преемниками. Данные, которые должны быть подписаны / проверены, хешируются, а результат 
   обрабатывается непосредственно через алгоритм ECDSA без дополнительного хеширования. 
   По умолчанию используется хеш-функция SHA-1 [10], а sha_size (
   см. Разделы 5.4 и 5.8) - 20. Однако альтернативная хеш-функция, такая как одна из 
   новых хеш-функций SHA, указанных в FIPS 180-2 [10], может использоваться вместо этого, 
   если сертификат, содержащий открытый ключ EC, явно требует использования другой 
   хеш-функции. (Механизм определения требуемой хэш-функции не был стандартизирован, 
   но это положение предусматривает такую ​​стандартизацию и устраняет необходимость 
   обновления этого документа в ответ. В будущих PKIX RFC может быть выбрано, например, 
   определение хэш-функции, которая будет использоваться с открытый ключ в поле 
   параметров subjectPublicKeyInfo.)

   Все подписи RSA должны быть сгенерированы и проверены в соответствии с блоком 
   типа 1 PKCS # 1 [12].
   
# 6.  Cipher Suites

   В таблице ниже определены новые наборы шифров ECC, в которых используются алгоритмы 
   обмена ключами, указанные в разделе 2.

     CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA           = { 0xC0, 0x01 }
     CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA        = { 0xC0, 0x02 }
     CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA   = { 0xC0, 0x03 }
     CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA    = { 0xC0, 0x04 }
     CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA    = { 0xC0, 0x05 }

     CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA          = { 0xC0, 0x06 }
     CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA       = { 0xC0, 0x07 }
     CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA  = { 0xC0, 0x08 }
     CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA   = { 0xC0, 0x09 }
     CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA   = { 0xC0, 0x0A }

     CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA             = { 0xC0, 0x0B }
     CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA          = { 0xC0, 0x0C }
     CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA     = { 0xC0, 0x0D }
     CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA      = { 0xC0, 0x0E }
     CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA      = { 0xC0, 0x0F }

     CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA            = { 0xC0, 0x10 }
     CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA         = { 0xC0, 0x11 }
     CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA    = { 0xC0, 0x12 }
     CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA     = { 0xC0, 0x13 }
     CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA     = { 0xC0, 0x14 }

     CipherSuite TLS_ECDH_anon_WITH_NULL_SHA            = { 0xC0, 0x15 }
     CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA         = { 0xC0, 0x16 }
     CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA    = { 0xC0, 0x17 }
     CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA     = { 0xC0, 0x18 }
     CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA     = { 0xC0, 0x19 }

                        Table 5: TLS ECC cipher suites

   Метод обмена ключами, шифр и алгоритм хеширования для каждого из этих 
   наборов шифров легко определяются путем изучения имени. Шифры (кроме шифров AES) 
   и хэш-алгоритмы определены в [2][2] и [3][3]. Шифры AES определены в [19].

   Server implementations SHOULD support all of the following cipher
   suites, and client implementations SHOULD support at least one of
   them: TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,
   TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,
   TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, and
   TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA.

# 7. Соображения безопасности

   Вопросы безопасности обсуждаются в этой памятке.

   Для рукопожатий TLS с использованием наборов шифров ECC, соответственно, 
   применяются соображения безопасности, указанные в приложениях D.2 и D.3 [2] и [3].

   Обсуждения безопасности, относящиеся к ECC, можно найти в [6] и [7]. Одной из важных 
   проблем, которую должны учитывать разработчики и пользователи, является выбор 
   эллиптической кривой. Рекомендации по выбору подходящего размера эллиптической 
   кривой приведены в таблице 1.

   Помимо размера эллиптической кривой, основной проблемой является структура эллиптической 
   кривой. Как правило, более консервативно использовать эллиптические кривые с минимально 
   возможной алгебраической структурой. Таким образом, случайные кривые более консервативны, 
   чем специальные кривые, такие как кривые Коблица, а кривые над F_p с p random более 
   консервативны, чем кривые над F_p с p специальной формы (и кривые над F_p с p random 
   могут считаться более консервативными, чем кривые больше F_2 ^ m, поскольку для 
   характеристики 2 нет выбора между несколькими полями одинакового размера). Обратите 
   внимание, однако, что алгебраическая структура также может привести к повышению эффективности 
   реализации, поэтому разработчикам и пользователям может потребоваться балансировать 
   консерватизм с потребностью в эффективности. Конкретные атаки известны только против 
   очень небольшого числа специальных классов кривых, таких как суперсингулярные кривые, 
   и эти классы исключены из стандартов ECC, на которые ссылается этот документ [6], [7].

   Другой проблемой является возможность катастрофических отказов, когда широко используется 
   одна эллиптическая кривая. В этом случае атака на эллиптическую кривую может привести к 
   компрометации большого количества ключей. Опять же, это беспокойство, возможно, необходимо 
   уравновесить с повышением эффективности и совместимости, связанным с широко используемыми 
   кривыми. Существенную дополнительную информацию о выборе эллиптической кривой можно найти 
   в [5], [6], [7] и [11].

   Разработчики и пользователи также должны учитывать, нужна ли им прямая секретность. Прямая 
   секретность означает свойство, что ключи сеанса не скомпрометированы, если статические 
   сертифицированные ключи, принадлежащие серверу и клиенту, скомпрометированы. Алгоритмы 
   обмена ключами ECDHE_ECDSA и ECDHE_RSA обеспечивают прямую защиту секретности в случае 
   компрометации ключа сервера, в то время как ECDH_ECDSA и ECDH_RSA этого не делают. Точно 
   так же, если клиент предоставляет статический сертифицированный ключ, аутентификация 
   клиента ECDSA_sign обеспечивает защиту прямой секретности в случае компрометации ключа клиента, 
   а ECDSA_fixed_ECDH и RSA_fixed_ECDH - нет. Таким образом, чтобы получить полную защиту 
   прямой секретности, ECDHE_ECDSA или ECDHE_RSA должны использоваться для обмена ключами, 
   с ECDSA_sign, используемым для аутентификации клиента, если это необходимо. Здесь опять 
   же, возможно, придется уравновесить преимущества прямой секретности в плане безопасности 
   с повышенной эффективностью, предлагаемой другими вариантами.

# 8. Соображения по поводу IANA

   В этом документе описаны три новых пространства имен для использования с протоколом TLS:

   * NamedCurve (раздел 5.1)
   * ECPointFormat (Раздел 5.1)
   * ECCurveType (раздел 5.4)

   Для каждого пространства имен этот документ определяет начальные назначения значений и 
   определяет диапазон из 256 значений (NamedCurve) или восьми значений (ECPointFormat и 
   ECCurveType), зарезервированных для частного использования. Любые дополнительные 
   назначения требуют согласованного действия IETF [16].

# 9. Благодарности

   Авторы выражают благодарность Биллу Андерсону и Тиму Дирксу.

# 10. Ссылки

## 10.1. Нормативные ссылки

[1]:   Bradner, S., "Key Words for Use in RFCs to Indicate Requirement
     Levels", RFC 2119, March 1997.

[2]: Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",     RFC 2246, January 1999.)

[3]: Dierks, T. and E. Rescorla, "The Transport Layer Security (TLS) Protocol Version 1.1", RFC 4346, April 2006.

[4]:   Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and
     T. Wright, "Transport Layer Security (TLS) Extensions", RFC
     4366, April 2006.

[5]:   SECG, "Elliptic Curve Cryptography", SEC 1, 2000,
     <http://www.secg.org/>.

[6]: IEEE, "Standard Specifications for Public Key Cryptography",
     IEEE 1363, 2000.

[7]:   ANSI, "Public Key Cryptography For The Financial Services
     Industry: The Elliptic Curve Digital Signature Algorithm
     (ECDSA)", ANSI X9.62, 1998.

[8]:   International Telecommunication Union, "Information technology
     - Abstract Syntax Notation One (ASN.1): Specification of basic
     notation", ITU-T Recommendation X.680, 2002.

[9]:   International Telecommunication Union, "Information technology
     - ASN.1 encoding rules: Specification of Basic Encoding Rules
     (BER), Canonical Encoding Rules (CER) and Distinguished
     Encoding Rules (DER)", ITU-T Recommendation X.690, 2002.

[10]:  NIST, "Secure Hash Standard", FIPS 180-2, 2002.

[11]:  NIST, "Digital Signature Standard", FIPS 186-2, 2000.

[12]:  RSA Laboratories, "PKCS#1: RSA Encryption Standard version
     1.5", PKCS 1, November 1993.

[13]:  SECG, "Recommended Elliptic Curve Domain Parameters", SEC 2,
     2000, <http://www.secg.org/>.

[14]:  Polk, T., Housley, R., and L. Bassham, "Algorithms and
     Identifiers for the Internet X.509 Public Key Infrastructure
     Certificate and Certificate Revocation List (CRL) Profile",
     RFC 3279, April 2002.

[15]:  Housley, R., Polk, T., Ford, W., and D. Solo, "Internet X.509
     Public Key Infrastructure Certificate and Certificate
     Revocation List (CRL) Profile", RFC 3280, April 2002.

[16]:  Narten, T. and H. Alvestrand, "Guidelines for Writing an IANA
     Considerations Section in RFCs", RFC 2434, October 1998.

## 10.2.  Informative References

[17]:  Harper, G., Menezes, A., and S. Vanstone, "Public-Key
     Cryptosystems with Very Small Key Lengths", Advances in
     Cryptology -- EUROCRYPT '92, LNCS 658, 1993.

[18]:  Lenstra, A. and E. Verheul, "Selecting Cryptographic Key
     Sizes", Journal of Cryptology 14 (2001) 255-293,
     <http://www.cryptosavvy.com/>.

[19]:  Chown, P., "Advanced Encryption Standard (AES) Ciphersuites for
     Transport Layer Security (TLS)", RFC 3268, June 2002.


# Appendix A.  Equivalent Curves (Informative)

Все кривые NIST [11] и некоторые кривые ANSI [7] эквивалентны кривым, перечисленным 
в разделе 5.1.1. В следующей таблице несколько имен в одной строке представляют собой 
псевдонимы одной и той же кривой.

             ------------------------------------------
                 Имена кривых, выбранные различными 
                  организациями по стандартизации
             ------------+---------------+-------------
             SECG        |  ANSI X9.62   |  NIST
             ------------+---------------+-------------
             sect163k1   |               |   NIST K-163
             sect163r1   |               |
             sect163r2   |               |   NIST B-163
             sect193r1   |               |
             sect193r2   |               |
             sect233k1   |               |   NIST K-233
             sect233r1   |               |   NIST B-233
             sect239k1   |               |
             sect283k1   |               |   NIST K-283
             sect283r1   |               |   NIST B-283
             sect409k1   |               |   NIST K-409
             sect409r1   |               |   NIST B-409
             sect571k1   |               |   NIST K-571
             sect571r1   |               |   NIST B-571
             secp160k1   |               |
             secp160r1   |               |
             secp160r2   |               |
             secp192k1   |               |
             secp192r1   |  prime192v1   |   NIST P-192
             secp224k1   |               |
             secp224r1   |               |   NIST P-224
             secp256k1   |               |
             secp256r1   |  prime256v1   |   NIST P-256
             secp384r1   |               |   NIST P-384
             secp521r1   |               |   NIST P-521
             ------------+---------------+-------------

      Таблица 6: Эквивалентные кривые, определенные SECG, ANSI и NIST


# Authors' Addresses

   Simon Blake-Wilson
   SafeNet Technologies BV
   Amstelveenseweg 88-90
   1075 XJ, Amsterdam
   NL

   Phone: +31 653 899 836
   EMail: sblakewilson@safenet-inc.com


   Nelson Bolyard
   Sun Microsystems Inc.
   4170 Network Circle
   MS SCA17-201
   Santa Clara, CA  95054
   US

   Phone: +1 408 930 1443
   EMail: nelson@bolyard.com


   Vipul Gupta
   Sun Microsystems Laboratories
   16 Network Circle
   MS UMPK16-160
   Menlo Park, CA  94025
   US

   Phone: +1 650 786 7551
   EMail: vipul.gupta@sun.com


   Chris Hawk
   Corriente Networks LLC
   1563 Solano Ave., #484
   Berkeley, CA  94707
   US

   Phone: +1 510 527 0601
   EMail: chris@corriente.net


   Bodo Moeller
   Ruhr-Uni Bochum
   Horst-Goertz-Institut, Lehrstuhl fuer Kommunikationssicherheit
   IC 4/139
   44780 Bochum
   DE

   Phone: +49 234 32 26795
   EMail: bodo@openssl.org










































Blake-Wilson, et al.         Informational                     [Page 34]

RFC 4492               ECC Cipher Suites for TLS                May 2006


Full Copyright Statement

   Copyright (C) The Internet Society (2006).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).







Blake-Wilson, et al.         Informational                     [Page 35]
